// Code generated by ggconfig. DO NOT EDIT.

package gconfig

import (
	"os"
	"sync"

	"github.com/apopov-app/ggconfig/runtime"
)

type Provider struct {
	Package string
	NewAllFromParsed func(y *runtime.YAML, mapKey func(string) string) any
}

var (
	registryMu sync.RWMutex
	registry = map[string]Provider{}
)

func Register(pkg string, p Provider) {
	registryMu.Lock()
	defer registryMu.Unlock()
	registry[pkg] = p
}

func Providers() map[string]Provider {
	registryMu.RLock()
	defer registryMu.RUnlock()
	out := make(map[string]Provider, len(registry))
	for k, v := range registry {
		out[k] = v
	}
	return out
}

// NewAllFromYAML builds a single package AllConfig from YAML bytes (YAML parsed once per call).
// Returns (nil, false, nil) if the package is not registered.
func NewAllFromYAML(pkg string, yamlData []byte) (any, bool, error) {
	y, err := runtime.ParseYAML(yamlData)
	if err != nil {
		return nil, false, err
	}
	registryMu.RLock()
	p, ok := registry[pkg]
	registryMu.RUnlock()
	if !ok || p.NewAllFromParsed == nil {
		return nil, false, nil
	}
	return p.NewAllFromParsed(y, func(k string) string { return k }), true, nil
}

// EnvConfig allows post-processing of env keys before os.Getenv, e.g. to inject prefixes.
type EnvConfig struct {
	mapKey func(string) string
}

func NewEnvConfig(mapKey func(key string) string) *EnvConfig {
	if mapKey == nil {
		mapKey = func(k string) string { return k }
	}
	return &EnvConfig{mapKey: mapKey}
}

type GlobalYamlConfig struct {
	path string
}

func NewGlobalYamlConfig(path string) *GlobalYamlConfig {
	return &GlobalYamlConfig{path: path}
}

type GlobalConfig struct {
	y *runtime.YAML
	mapKey func(string) string
}

// NewGlobalConfig creates app-wide config wrapper. Sources order does not matter.
// Supported sources:
// - *GlobalYamlConfig
// - *EnvConfig
func NewGlobalConfig(sources ...any) (*GlobalConfig, error) {
	g := &GlobalConfig{
		y:      &runtime.YAML{},
		mapKey: func(k string) string { return k },
	}
	var yamlPath string
	for _, s := range sources {
		switch t := s.(type) {
		case *EnvConfig:
			if t != nil && t.mapKey != nil {
				g.mapKey = t.mapKey
			}
		case *GlobalYamlConfig:
			if t != nil && t.path != "" {
				yamlPath = t.path
			}
		}
	}
	if yamlPath != "" {
		b, err := os.ReadFile(yamlPath)
		if err != nil {
			return nil, err
		}
		y, err := runtime.ParseYAML(b)
		if err != nil {
			return nil, err
		}
		g.y = y
	}
	return g, nil
}

